// coding: cp866
//-----------------------------------------------------------------------------
// []-возвращаемое значение

ex struct {                        
   uc  Name[DBSLEN];          // имя файла БД
   _i  Desk;                  // дескриптор (системный номер)
   _i  Mod;                   // флаг модификации файла 1-была модификация
   _i  Init;                  // флаг инициализации массива
} dbFile[DBMAXDBF];


ex struct {
   _l    RecCount;                 // количество записей в БД
   _i    RecLen;                   // длинна одной записи
   _l    CRec;                     // номер текущей записи в БД
   _l    COfs;                     // начал смещен в файле для текущ записи
   _i    Bof;                      // флаг попытки выхода за начало БД
   _i    Eof;                      // флаг попытки выхода за конец БД
   _i    FieldCount;               // количество полей в открытой БД
} dbHeaw[DBMAXDBF];

extern int   dbDebug;                       // флаг отладки

extern void  dbDPrn(unsigned char *, ...);  // функция вывода отлад информации


//-----------------------------------------------------------------------------
// ФУНКЦИИ ДЛЯ РАБОТЫ С ФАЙЛАМИ БАЗ ДАННЫХ
//-----------------------------------------------------------------------------
// определяет открыта ли БД в указанной области P1 [1-открыта, <0-нет базы]
extern int   dbOpenTest(int,unsigned char *);
//-----------------------------------------------------------------------------
// проверка целостности БД и заголовка, при необходимости ее корректировка
// P1-область, P2-имя файла БД. 
// [<0-ошибка БД, =0-файл без ошибок, >0-ошибка в файле была исправлена]
extern int   dbCheck (int,unsigned char *);
//-----------------------------------------------------------------------------
// создает файл БД P1 из массива dbField [<0-ошибка создания БД]
extern int   dbCreate(int,unsigned char *);
//-----------------------------------------------------------------------------
// открывает файл БД P2 в указанной области P2 [<0-ошибка открытия БД]
extern int   dbOpen  (int,unsigned char *);
//-----------------------------------------------------------------------------
// закрывает файл БД в указанной области P1
extern void  dbClose (int);
//-----------------------------------------------------------------------------
// первоначально инициализирует(резервирует) массив БД
extern int   dbInit  (int);
//-----------------------------------------------------------------------------
//  определение свободной области для работы с БД
extern int   dbSelectAvail(void);
//-----------------------------------------------------------------------------
//  очистить указанный массив БД
extern void  dbClear(int);
//----------------------------------------------------------------------------
//  очистить все массивы БД
extern void  dbClearALL(void);
//----------------------------------------------------------------------------
//  копировать структуру базы данных P1 в новый файл P2
//  [<0-ошибка,0-без ошибок]
extern int  dbStructCopy(unsigned char*,unsigned char*);
//----------------------------------------------------------------------------
//  перезапись файла БД P1 исключая записи, помеченные на удаление,
//  во временный файл P2
extern int   dbPack(unsigned char*,unsigned char*);
//----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// ФУНКЦИИ ДЛЯ РАБОТЫ С ПОЛЯМИ БАЗЫ ДАННЫХ
//-----------------------------------------------------------------------------
// определяет заполнен ли для области P1 массив P2 [<0-массив не заполнен]
extern int  dbFieldTest(int,int);
//-----------------------------------------------------------------------------
// для области P1 очищает массив P2
extern void  dbFieldClear(int,int);
//-----------------------------------------------------------------------------
// для области  P1 заполняет ячейку P2 массива полей данными о поле P2 БД
// P3-имя поля, P4-тип поля('C','N','F','L','D','B','I'), 
// P5-длинна поля, P6-колич знаков после запятой для полей типа 'N','F','B'
// [<0-ошибка параметров для заполнения массива полей БД]
// После определения последнего поля с помощью данной функции, нужно вызвать
// функцию dbClear() с указанием номера следующего поля.
extern int  dbFieldFill(int,int,unsigned char *,
                        unsigned char,unsigned char,unsigned char);
//-----------------------------------------------------------------------------
// для области P1 и номера поля P2 вернуть имя поля
extern unsigned char *dbFieldGetName(int,int);
//-----------------------------------------------------------------------------
// для области P1 и номера поля P2 вернуть тип поля
extern unsigned char  dbFieldGetType(int,int);
//-----------------------------------------------------------------------------
// для области P1 и номера поля P2 вернуть длинну поля
extern unsigned char  dbFieldGetLen(int,int);
//-----------------------------------------------------------------------------
// для области P1 и номера поля P2 вернуть колич цифр после запятой
extern unsigned char  dbFieldGetDec(int,int);
//-----------------------------------------------------------------------------
// [номер поля по имени] 
// P1-область, P2-(0-без учета регистра,1-с учетом регистра), P3-имя поля
extern int  dbFieldGetNumber(int,int,unsigned char *);
//-----------------------------------------------------------------------------
//  возвращает количество полей БД из указанной области
extern int  dbFieldCount(int);
//-----------------------------------------------------------------------------





//-----------------------------------------------------------------------------
// ФУНКЦИИ ДЛЯ РАБОТЫ С ЗАПИСЯМИ БАЗЫ ДАННЫХ
//-----------------------------------------------------------------------------
// для области P1 установить(логически) курсор на первую запись БД 
// [<0-нет записей]
extern long  dbGoFirst(int);
//-----------------------------------------------------------------------------
// для области P1 установить(логически) курсор на последнюю запись БД
// [<0-нет записей]
extern long  dbGoLast (int);
//-----------------------------------------------------------------------------
// для области P1 установить(логически) курсор на указанную запись P2 БД
// [<0-за границей БД]
extern long  dbGoRec  (int,long);
//-----------------------------------------------------------------------------
// для области P1 установить(логически) курсор на запись +P2 БД
// [<0-за границей БД]
extern long  dbGoSkip (int,long);
//-----------------------------------------------------------------------------
// [1-для данной области P1 была попытка выхода за верхнюю границу БД]
extern int   dbBof    (int);
//-----------------------------------------------------------------------------
// [1-для данной области P1 была попытка выхода за нижнюю границу БД]
extern int   dbEof    (int);
//-----------------------------------------------------------------------------
// для области P1 возвращает количество записей в БД
extern long  dbRecCount(int);
//-----------------------------------------------------------------------------
// [логический номер текущей записи для данной области P1]
extern long  dbRecCur (int);
//-----------------------------------------------------------------------------
// добавляет пустую запись в БД в текущей области P1 
// [<0-неверная длинна записи]
extern int   dbRecAdd (int);
//----------------------------------------------------------------------------
// записать буфер записи для области P1 на диск
extern int   dbRecWrite(int);
//----------------------------------------------------------------------------
// прочитать буфер записи для области P1 c диска
// [<0-запись не считана, >=0-нормальная запись(количество считанных байт)]
extern int   dbRecRead(int);
//----------------------------------------------------------------------------
// копировать буфер записи из одной области P1 в другую P2 [всегда 0]
extern int   dbRecCopy(int,int);
//----------------------------------------------------------------------------
// проверить является ли запись P2 (<0-текущая запись,>=0-номер записи)
// удаленной в БД открытой в области P1. [<0-ошибка,0-не удалена,1-удалена]
extern int   isRecDelete(int,long);
//----------------------------------------------------------------------------
// установить признак удаления записи P2 (<0-текущая запись,>=0-номер записи)
// удаленной в БД открытой в области P1. P3>0 -установить флаг, =0-снять флаг.
// [<0-ошибка,0-не удалена,1-удалена]
extern int   dbRecDelete(int,long,int);
//----------------------------------------------------------------------------
//  проверка признака удаления записи для области P1 
//  [=0-признак удаления не установлен, >0-установлен признак удаления записи]
extern int   isRecDFL(int);
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// ФУНКЦИИ ДЛЯ ЗАПИСИ И ЧТЕНИЯ ЗНАЧЕНИЙ ПОЛЕЙ БАЗЫ ДАННЫХ
//-----------------------------------------------------------------------------
// последний парамметр во всех функциях этой группы- это режим работы
// 0-работа с буфером, 1-работа напрямую с диском
// при работе с буфером используется буфер для одной записи
// для чтения всей записи в  буффер  используется комманда dbRecRead(Sel);
// для записи всей записи из буффера используется комманда dbRecWrite(Sel);
//-----------------------------------------------------------------------------
// для  текущ записи области P1 и поля P2(номер) P3(имя) записать строку P4
// если P2=-1 поле определяется по имени, иначе по номеру
extern long  dbFieldPutStr(int,int,unsigned char *,unsigned char *,int);
//-----------------------------------------------------------------------------
// для  текущ записи области P1 и поля P2(номер) P3(имя) записать дату P4
// если P2=-1 поле определяется по имени, иначе по номеру
// P4="D" -записывает в поле текущую дату
extern long  dbFieldPutDat(int,int,unsigned char *,unsigned char *,int);
//-----------------------------------------------------------------------------
// для  текущ записи области P1 и поля P2(номер) P3(имя) записать логич знач P4
// если P2=-1 поле определяется по имени, иначе по номеру
extern long  dbFieldPutLog(int,int,unsigned char *,unsigned char,int);
//-----------------------------------------------------------------------------
// для  текущ записи области P1 и поля P2(номер) P3(имя) записать значение P4
// если P2=-1 поле определяется по имени, иначе по номеру
extern long  dbFieldPutVal(int,int,unsigned char *,double,int);
//-----------------------------------------------------------------------------
// для  текущ записи области P1 из поля P2(номер) P3(имя) получить строку
// если P2=-1 поле определяется по имени, иначе по номеру
extern unsigned char *dbFieldGetStr(int,int,unsigned char *,int);
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// для  текущ записи области P1 из поля P2(номер) P3(имя) получить дату 
// если P2=-1 поле определяется по имени, иначе по номеру
// [дата из 8 символов в формате ГГГГММДД]
extern unsigned char *dbFieldGetDat(int,int,unsigned char *,int);
//-----------------------------------------------------------------------------
// для  текущ записи области P1 из поля P2(номер) P3(имя) получить логич знач
// если P2=-1 поле определяется по имени, иначе по номеру.[1 символ]
extern unsigned char  dbFieldGetLog(int,int,unsigned char *,int);
//-----------------------------------------------------------------------------
// для  текущ записи области P1 из поля P2(номер) P3(имя) получить значение
// если P2=-1 поле определяется по имени, иначе по номеру.
extern double  dbFieldGetVal(int,int,unsigned char *,int);
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ                   
//----------------------------------------------------------------------------
// [размер памяти структур библиотеки]
extern int  dbGetMemLib(void);
//-----------------------------------------------------------------------------
// [вычесленный размер БД]
extern long  dbFileSize(int);
//-----------------------------------------------------------------------------
// заполняет структуру dbtm текущими датой и временем 
// P1='D'-[текущая дата ГГГГММДД], P1='T'-[текущее время ЧЧММСС]
extern unsigned long  dbCurDate(unsigned char);
//-----------------------------------------------------------------------------
// для области P1 и поля P2 устанавливает указатель
// если P3=0 - в буфере записи, P3=1 - в файле БД.
// [Смещение в файле БД или -1,если записей в БД нет]
extern long  dbFieldOffset(int,int,int);
//-----------------------------------------------------------------------------
// модифицирует дату последнего обновления для заголовка БД
extern void  dbModifyDate(int);
//-----------------------------------------------------------------------------
// модифицирует количество записей БД для заголовка БД
extern int  dbModifyRecCount(int,int);
//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
// ФУНКЦИИ ДЛЯ РАБОТЫ С БУФЕРОМ
//----------------------------------------------------------------------------
// зарезервировать буфер P1 для дальнейшего использования
// [-1 неверный номер буфера, -2 буфер уже занят, >=0 номер буфера для работы]
extern int  dbBFInit(int);
//----------------------------------------------------------------------------
// поиск свободного буфера [номер свободного буфера]
extern int  dbBFBufferAvail(void);
//-----------------------------------------------------------------------------
// очистка буфера с указанным номером [0< -неверно задан номер буфера]
extern int  dbBFClear(int);
//----------------------------------------------------------------------------
// очистка всех буферов
extern void  dbBFClearALL(void);
//----------------------------------------------------------------------------
// [максимальное количество записей в буфере] P1-область БД, P2-номер буфера
extern int  dbBFRecInBuf(int,int);
//----------------------------------------------------------------------------
// чтение файла БД из области P1 в буфер P2 от текущей записи области P1.
// P3- количество считываемых записей
// [0< неверно задана область или номер буфера,
//  0= нечего считывать из БД, >0 количество считанных записей в буфер]
extern int  dbBFRead(int,int,int);
//----------------------------------------------------------------------------
// запись буфера P2 в файл БД области P1, 
// P3-количество записываемых записей, если не было добавлений
// P4-режим записи (DBBFADD,DBBFWRITE,DBBFWRADD)
// [0< неверно задана область или номер буфера,
//  0= ничего не записали, >0 количество записанных записей в файл БД]
extern int  dbBFWrite(int,int,int,int);
//----------------------------------------------------------------------------
// переход на указанную запись P2 в буфере P1
// [0< неверно задан номер буфера или номер записи в буфере
//  >0 номер записи в буфере]
extern int  dbBFGoRec(int,int);
//----------------------------------------------------------------------------
// переход на запись в буфере P1 на количество записей указанное в P2
// [0< неверно задан номер буфера или номер записи в буфере
// >=0 номер текущей записи в указанной области]
extern int  dbBFGoSkip(int,int);
//----------------------------------------------------------------------------
// установить указатель на первую запись(N0) в буфере P1
// [0< неверно задан номер буфера
//  =0 номер текущей записи в указанной области (N0)]
extern int dbBFGoFirst(int);
//----------------------------------------------------------------------------
// установить указатель на последнюю запись в буфере P1
// [0< неверно задан номер буфера
//  >0 номер текущей(последней) записи в указанной области]
extern int  dbBFGoLast(int);
//----------------------------------------------------------------------------
// проверка выхода за верхнюю границу в буфере P1 после последнего 
// перемещения указателя в буфере [0-не было выхода, 1-был выход]
extern int  dbBFBof(int);
//----------------------------------------------------------------------------
// проверка выхода за нижнюю границу в буфере P1 после последнего 
// перемещения указателя в буфере [0-не было выхода, 1-был выход]
extern int  dbBFEof(int);
//----------------------------------------------------------------------------
// [номер текущей записи в буфере P1]
extern int  dbBFRecCur(int);
//----------------------------------------------------------------------------
// [количество записей в буфере P1 считая и удаленные]
extern int  dbBFRecCount(int);
//----------------------------------------------------------------------------
// копировать текущую запись БД из области P1 в текущую запись буфера P2
// [0< неверно задан номер буфера или области
//  >0 запись нормально скопирована]
extern int  dbBFRecCopyBuf(int,int);
//----------------------------------------------------------------------------
// копировать текущую запись из буфера P2 в текущую запись области P1 
// [0< неверно задан номер буфера или области
//  >0 запись нормально скопирована]
extern int  dbBFBufCopyRec(int,int);
//----------------------------------------------------------------------------
//  установка признака удаления записи P2 в буфере P1.
//  P3=0-убрать признак удаления, P3>0-установить признак удаления.
extern int  dbBFRecDelete(int,int,int);
//----------------------------------------------------------------------------
//  проверка признака удаления записи P2 в буфере P1
extern int  isBFRecDelete(int,int);
//----------------------------------------------------------------------------
//  возвpащает номеp поля по его имени, если поля нет, то возращает -1
//  P2=0 -без учета регистра, иначе с учетом регистра
extern int  dbFieldGetNum(int,int,uc*);
//----------------------------------------------------------------------------
