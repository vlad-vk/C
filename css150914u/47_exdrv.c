// coding: cp866
//---------------------------------------------------------------------------
// Читается база каналов из файла codus.chb в масив CB[].
// CB[].dt - тип драйвера  (LOC, SER, NBW, TCP)
// CB[].dn - номер канала  (LOC), номер порта (SER), номер станции (NBW,TCP)
// CB[].t  - тип перменной (1-входная,  2-выходная)
// Затем, в зависимости от поля CB[].dt (тип драйвера), номера каналов
// (каналы CB[] по порядку) заносятся в массивы номеров каналов
// соответствующих драйверов:
// for(b=0;b<Mxxx;b++){
//    if (CB[b].dt==0){ DLOC[HLOC]=b; HLOC++; }
//
//    if (CB[b].dt==1){ DSER[HSER]=b; HSER++; }
//    if (CB[b].dt==2){ DNBW[HNBW]=b; HNBW++; }
//    if (CB[b].dt==3){ DTCP[HTCP]=b; HTCP++; }
// }
// Количество считанных каналов остается в соответствующих переменных:
// HLOC, HSER, HNBW, HTCP.
// При вызове драйвера, из массивов Dxxx[] поочередно (от 0 до Hxxx)
// берутся номера каналов в CB[] и, в зависимости от типа канала CB[].t,
// проводится обмен данными.
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Локальный драйвер
_i DRV_Loc(vd){
   _i a=0;
   //------------------------------------------------------------------------
   // заполнить массив локальных переменных
   CBL[ 0]=0;                       // пустое значение
   CBL[ 1]=Empty_Loops_on_tick;     // пустых циклов за тик
   CBL[ 2]=Empty_Loops_on_second;   // пустых циклов за секунду

   CBL[ 3]=vmnu;                    // номер текущего меню
// CBL[ 4]=MENUSC;                  // код клавиши генерируемый меню
// CBL[ 5]=GOPKCODE;                // код пол генер клавиши для запрос операт
// CBL[ 6]=GetDATA;                 // флаг ввода данных (1-ввод данных,2-нет)
// CBL[ 7]=LASTKEY;                 // последняя нажатая клавиша для внеш комм
// CBL[ 8]=SCANCODE;                // скан  код последней нажатой клавиши
// CBL[ 9]=ASCICODE;                // ASCII код ...
// CBL[10]=MESSAGE_C;               // номер записываемого сообщения
                                    // определяется в rMessageWrt()
// CBL[11]=MESSAGE_P;               // номер предыдущего сообщения
// CBL[12]=WaitPressKey;            // кол-во секунд ожидания нажатия клавиши
// CBL[13]=RUS_ENG;                 // переключение руccкий-английский
// CBL[14]=0;                       // флаг нормального завершения программы
   CBL[15]=SSTAT;                   // статус драйвера COM порта
   CBL[16]=NSTAT;                   // статус драйвера NetBIOS
   CBL[17]=TSTAT;                   // статус драйвера TCP/IP
   CBL[18]=WKDAY;                   //
// CBL[19]=VALCMD;                  // флаг передачи значения из файла CMD
// CBL[20]=DisF;                    // флаг запрета изменений
// CBL[21]=Dism;                    // запрет отображения меню
// CBL[22]=DisC;                    // запрет изм знач от кнопки
// CBL[23]=DisG;                    // запрет ввода значений
// CBL[24]=RQSERCNT;                // количество посланных запросов за 10сек
// CBL[25]=TOSERCNT;                // количество таймаутов за 10 сек
// CBL[26]=ANSERCNT;                // количество принятых ответов за 10 сек
// CBL[27]=CREP;                    // номер текущего отчета
// CBL[28]=FREP;                    // флаг генерации текущего отчета
// CBL[29]=0;                       // флаг включ-выключ фильтра сообщен флага
// CBL[30]=0;                       // флаг включ-выключ фильтра сообщен ввода
   CBL[31]=CEKR;                    // номер текущего екрана
// CBL[32]=LKSET_CMD;               // флаг установки кода клавиши из прогр CMD
// CBL[33]=NUMAL_CMD;               // номер сообщ из _al.ini в стр статуса(CMD)
// CBL[34]=SECAL_CMD;               // кол-во сек отображ этого сообщения  (CMD)
// CBL[35]=ERRAL_CMD;               // флаг вывода сообщения, как ошибку   (CMD)
// CBL[36]=YEA_CMD;                 // текущая дата: год
// CBL[37]=MON_CMD;                 // текущая дата: месяц
// CBL[38]=DAY_CMD;                 // текущая дата: день
// CBL[39]=HOU_CMD;                 // текущая дата: час
// CBL[40]=MIN_CMD;                 // текущая дата: минуты
// CBL[41]=SEC_CMD;                 // текущая дата: секунды
   CBL[42]=codus_version;           // текущая версия программы
// CBL[43]=0;                       // сигнализация (0-выключена)
// CBL[44]=0;                       // загрузка программы CODUS
// CBL[45]=0;                       // пароль 1
// CBL[46]=0;                       // пароль 1.1
// CBL[47]=0;                       // пароль 2
// CBL[48]=0;                       // пароль 2.1
// CBL[49]=0;                       // пароль 3
// CBL[50]=0;                       // пароль 3.1
// CBL[51]=0;                       // пароль 4
// CBL[52]=0;                       // пароль 4.1
// CBL[55]=TO_COM;                  // Таймаут обмена по COM порту (=1)
// CBL[56]=TO_NBW;                  // Таймаут обмена по NetBIOS   (=1)
// CBL[57]=NBREQASK;                // Счетчик ответов на запросы по NetBIOS
// CBL[58]=0;                       // AUTHCODE- код авторизации с нижн уровня
//
// CBL[61]=CURGETVAL;               // номер текущ ввод CURGETVAL чисел
// CBL[62]=CURGETDAT;               // номер текущ ввод CURGETDAT дата,время
// CBL[63]=CURGETSTR;               // номер текущ ввод CURGETSTR строки 'W'
//
// CBL[65]=LASTINI_P;               // номер предыдущего загруженного файла
// CBL[66]=LASTINI_C;               // номер текущего загруженного файла
// CBL[67]=FNINI_CMD;               // номер вызываемого INI файла
// CBL[68]=FNSET_CMD;               // флаг  вызыва указанного файла
// CBL[69]=FVLSTPAGE;               // номер последн страницы просматрив файла
// CBL[70]=FVCURPAGE;               // номер текущей страницы просматрив файла
// CBL[71]=FVCURREC;                // номер первой записи окна актив файла
// CBL[72]=FVDBCREC;                // номер записи мышки  окна актив файла
// CBL[73]=FVCURFNH;                // высота шрифта отображ текущ файла
// CBL[74]=FVCURHST;                // кол-во строк в окне отображ файла
// CBL[75]=FVSELDBA;                // номер активной области БД просмотра
// CBL[80]=TRCURREC;                // текущ запись активного тренда

   //------------------------------------------------------------------------
   // перенос запрашиваемых переменных в общую базу
   for(a=1;a<HLOC;a++){
      // если номер в массиве CB[] больше 0 и меньше макс считанного # канала
      if (DLOC[a]>0 && DLOC[a]<HCB){
         // если в базе каналов CB[] определен номер меньше максимально
         // допустимого для локального массива CBL
         if (CB[DLOC[a]].dd>0 && CB[DLOC[a]].dd<MLOC){
             CB[DLOC[a]].v=CBL[CB[DLOC[a]].dd];
//                             |  +- номер переменной в массиве CB []
//                             +---- номер переменной в массиве CBL[]
         }
      }
   }
   //------------------------------------------------------------------------
   return(0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// передача значения после обработки ответа
vd COMAnsVal(ui p, uc ch){
// // если был сделан запрос на установку значения на канале на удаленном PCCS
// if(FSRS[CBSR[CSSER]]>0) FSRS[CBSR[CSSER]]=2;
   // если был получен ответ на запрос
   if(ch=='z'){
      REREQS=0;
      ANSERCNT++; COMBusy[p]=0; return;
   }
   // принятие ответа на запрос
   if(ch=='q'){
      COMCVal[p]=COMANS[p].Val;
      CB[COMCCh[p]].v=COMCVal[p];
      CBS[CBSR[COMCCh[p]]]=COMCVal[p];
      REREQS=0;
      return;
   }
   // подтверждение принятия команды установки на удаленном PCCS
   if(ch=='a'){
      FSRS[CBSR[CSSER]]=0;   //
      CSSER=0;               //
      REREQS=0;              // сбросить флаг повторного запроса 
   }
   return;
}
//---------------------------------------------------------------------------
vd SetNextCCSER(vd){
   int ch=-1,j=0,a=0;
   for(;;){
       ch++; if(ch>MCH){ break; }
       for(a=0;a<HSER;a++){
            CCSER++;
            if(CCSER<HSER){
              if(CB[DSER[CCSER]].t==1||CB[DSER[CCSER]].t==3){ break; }
            } else { CCSER=-1; }
       }
       // проверка номеров разрешенных и запрещенных станций контроллеров(PCCS)
       for(j=0;j<HCSE;j++){
//         DPrn(6,1,"06:HCSEnable:j=%d:CB[x].dn=%d:PCCSEnable[j]=%d.\n",j,CB[DSER[CCSER]].dn,PCCSEnable[j]);
           if(CB[DSER[CCSER]].dn==PCCSEnable[j]) break;
       }
       if(j>=HCSE){ continue; }
       else       { break;    }
   }
}
//---------------------------------------------------------------------------
// драйвер COM портов
vd DRV_Ser(_i p){
   //------------------------------------------------------------------------
   // установить флаг таймаута обмена по COM порту
   if (TOSERCNT>RQSERCNT-FAULSER){ TO_COM=1; }
   else                          { TO_COM=0; }
   //------------------------------------------------------------------------
   // каждые  5 мсек делаем проверку таймаута и форм запрос для след канала
   if (MTimer(7,'m',2)==2){
       MTimer(7,'m',0);
       // если программа находится в режиме ожидания приема
       if (COMBusy[p]==2){
           // если текущий счетчик таймаута приема больше заданного
           if (TOInp[p]>4){
               // очистить программный буфер приема и перейти к запросу
               // следующего значения
               DPrn(6,0,"06:RTO.\n"); ClearCB(p);
           };  TOSERCNT++;
       };  COMBusy[p]=0;
   }
   //------------------------------------------------------------------------

   //------------------------------------------------------------------------
   //  Формируем запрос
   if (COMBusy[p]==0){
       // если не был принят ответ на запрос повторяем запрос по этому же
       // каналу  два раза,  а затем переходим к следующему
       if (REREQS> REREQH) REREQS=0;
       if (REREQS==0) SetNextCCSER(); REREQS++;
       //
       if((CBSF[CBSN]==2)&&(CB[CBSN].t==2||CB[CBSN].t==3)){
          //-----------------------------------------------------------------
          // если это переменная на установку
          COMPutCH(p, CB[CBSN].dn, CB[CBSN].dd, CB[CBSN].v); CBSF[CBSN]=0;
       } else {
          //-----------------------------------------------------------------
          // если это входная переменная и нет каналов на установку
          if(FSRS[CBSR[CCSER]]==0 &&
            (CB[DSER[CCSER]].t==1||CB[DSER[CCSER]].t==3) && CSSER==0){
             COMReqCH(p,NSER[CCSER],SSER[CCSER]);
          } else {
          //-----------------------------------------------------------------
          // если был определен канал на установку (номер канала д.б.>0)
             if(FSRS[CBSR[CSSER]]==2 && (CB[CSSER].t==2 || CB[CSSER].t==3)){
                // D: Defined channel[%d] FSRS=%d CB.t=%d for set value.
                sprintf(SMSG[MMSG],SMSG[113],CSSER,FSRS[CBSR[CSSER]],CB[CSSER].t);
                DPrn(2,0,"02:%s\n",SMSG[MMSG]);
                COMPutCH(p, CB[CSSER].dn,CB[CSSER].dd,CB[CSSER].v);
//              FSRS[CBSR[CSSER]]=4;
             } else {
                // D: Not defined type channel for requests under COM
                // [CSSER=%d FSRS=%d CB.t=%d]
                sprintf(SMSG[MMSG],SMSG[114],CSSER,FSRS[CBSR[CSSER]],CB[CSSER].t);
                DPrn(2,0,"02:%s\n",SMSG[MMSG]);
                COMReqCH(p, NSER[CCSER],SSER[CCSER]);
             }
          }
          if(REREQS==1) RQSERCNT++;
          //-----------------------------------------------------------------
       }
   }
   //------------------------------------------------------------------------
   return;
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// драйвер NetBios
_i DRV_NBw(vd){
   _i  a=0, b=0, f=0, i=0, o=0;
   _i ns=NNBW[CNBQ];                   // номер запрашиваемой станции
   // Установка флага таймаута обмена данными по сети NetBIOS
   if (STNBW>(NBWTO/10)){ TO_NBW=1; }
   else                 { TO_NBW=0; }
   // Обнулить список каналов на передачу установок
   for(a=0;a<MSCH;a++){ NBST[STC].cq[a]=0; NBST[STC].ca[a]=0; }
   // Определение запросов
   for(a=CNBQ;a<HNBW;a++){
       // если номер удаленной станции не совпал с начальным определенным
       if (NNBW[a]!=ns){ break; }
       //--------------------------------------------------------------------
       // если это входной канал - внести его в запрос
       if (CB[DNBW[a]].t==1||CB[DNBW[a]].t==3){
           // номер канала на удаленной станции для запроса
           NBRQ[QRC].cq[i]=SNBW[a];
           // номер в массивах каналов CB[]
           NBRQ[QRC].ca[i]=a;
           // изменить счетчик канала
           i++;
           if(i>=MRCH){ break; }
       }
       //--------------------------------------------------------------------
       // если это выходной канал - внести его в посылку установки
       if((CB[DNBW[a]].t==2||CB[DNBW[a]].t==3) && (FNBS[a]==2)){
           DPrn(31,0,"31:1 exDRV_NBW [o++] FNBS==2, CB[%d]=%f CBN[%d]=%f\n",
                           DNBW[a],CB[DNBW[a]].v, a,CBN[a]);
           if(FNBS[a]==2){
              CB[DNBW[a]].v=CBN[a]; f=1;
              DPrn(31,0,"31:2 exDRV_NBW [o++] FNBS==2, CB[%d]=%f CBN[%d]=%f\n",
                          DNBW[a],CB[DNBW[a]].v, a,CBN[a]);
              NBST[STC].cq[o]=SNBW[a];
              NBST[STC].ca[o]=a;
              o++;
              if(o>=MRCH){ break; }
           }; FNBS[a]=0;
       }
       //--------------------------------------------------------------------
   }
   // остальной список дополняется нулями
   for(b=i;b<MRCH;b++){ NBRQ[QRC].cq[b]=0; NBRQ[QRC].ca[b]=0; }
   for(b=o;b<MSCH;b++){ NBST[STC].cq[b]=0, NBST[STC].ca[b]=0; }
   // переустанавливаем счетчик текущего элемента в массивах каналов
   if (a>=HNBW){ CNBQ=0; }
   else        { CNBQ=a; }
   // если был определен хоть один канал установки
   if (o>0&&TO_NBW==0){
       DPrn(31,0,"31:SetToNet o=%d\n",o);
       WS_NB__SetToNet(ns);
   }
   // если был определен хоть один канал запроса
   if (i>0){
       if(Debug(30)> 0) printf("q%d ",i);
       DPrn(31,0,"31:ReqToNet i=%d\n",i);
       WS_NB__ReqToNet(ns);
       STNBW++; if(STNBW>NBWTO+10){ STNBW=NBWTO+10; }
   }
   //------------------------------------------------------------------------
   // если сеть NETBIOS не работает - выдать сообщение в строку статуса
   // и записать сообщение в файл сообщений
   if (STNBW==(NBWTO/2)){ CBNUMMSGP[MAXMCH]=15; }
   if (STNBW> (NBWTO/2)&&STNBW<NBWTO){
       if(ErrCNT==0){
          sprintf(STAT[1].str,LALR[15].mes); STAT[1].cnt=10;
       }; STNBO=0;
   }
   // если работа сети NETBIOS восстановлена - выдать сообщение
   if (STNBO==(NBWTO/5)){
       if(ErrCNT==0){
          sprintf(STAT[1].str,LALR[16].mes); STAT[1].cnt=20;
       }; CBNUMMSGP[MAXMCH]=16;
   }
   return(0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// драйвер TCP/IP
_i DRV_TCP(_i md){
   // инициализация драйвера TCP
   if(md==0){ TCP_init(); }
   // обмен данными
   if(md==1){ TCP_exchange(); }
   // выключение драйвера TCP
   if(md==2){ TCP_close(); }
   return(0);
}
//---------------------------------------------------------------------------
