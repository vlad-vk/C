// coding: cp866
//---------------------------------------------------------------------------
#include "../include.h"
#include "../define.h"
#include "nbwsgw.h"

//---------------------------------------------------------------------------
vd  WS_NB__ZeroWS_R1(uc ncb){
    memset(&WS_R1[ncb], 0, sizeof(WS_R1[ncb]));
    return;
}
//---------------------------------------------------------------------------
vd  WS_NB__ZeroWS_R2(uc ncb){
    memset(&WS_R2[ncb], 0, sizeof(WS_R2[ncb]));
    return;
}
//---------------------------------------------------------------------------
vd  WS_NB__ZeroWS_R7(uc ncb){
    memset(&WS_R7[ncb], 0, sizeof(WS_R7[ncb]));
    return;
}
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
vd  WS_NB__ZeroWS_S1(uc ncb){
    memset(&WS_S1[ncb], 0, sizeof(WS_S1[ncb]));
    return;
}
//---------------------------------------------------------------------------
vd  WS_NB__ZeroWS_S2(uc ncb){
    memset(&WS_S2[ncb], 0, sizeof(WS_S2[ncb]));
    return;
}
//---------------------------------------------------------------------------
vd  WS_NB__ZeroWS_S7(uc ncb){
    memset(&WS_S7[ncb], 0, sizeof(WS_S7[ncb]));
    return;
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Формирование ответного блока для сетевого ответа
vd WS_NB__Answer(ui inncb, ui ouncb){
   ui i =0;
   ui NV=0;
   ul ltime=0;
   // Передача буфера принятого запроса в структуру запроса
   memcpy(&WS_R1[inncb],&WS_RD[inncb],504);
   // Очистить буфер принятого запроса
   WS_NB__ZeroRBF(inncb);
   // Очистить буфер посылки ответа на запрос
   WS_NB__ZeroSBF(ouncb);
   // Очистить структуру посылки ответа на запрос
   WS_NB__ZeroWS_S2(ouncb);
   WS_S2[ouncb].Code=2;                          // Код
   WS_S2[ouncb].NReq=WS_R1[inncb].NReq;          // Номер запроса
   ltime=time(NULL);
   WS_S2[ouncb].Time=(ul)ltime;                  // Время обновления
   if (WS_R1[inncb].NData>=MRCH){ WS_R1[inncb].NData=MRCH-1; }
   for(i=0; i<WS_R1[inncb].NData; i++){
       NV=(WS_R1[inncb].ReqData[i] & 0x0fff);    // Данные
       WS_S2[ouncb].Data[i]=CB[NV].v;            // Значение в буфер
   }
   WS_S2[ouncb].Const[1]=2;
   // Очистить структуру принятого запроса
   WS_NB__ZeroWS_R1(inncb);
   return;
}
//---------------------------------------------------------------------------


//--------------------------------------------------------------------------
// Передача принятых из сети данных в массив обмена
vd WS_NB__GetFromNet(ui n){
   ui i=0,NV=0;
   // Передача буфера принятых данных в структуру принятых данных
   memcpy (&WS_R7[n],&WS_RD[n],504);
   // Очистить буфер приема принятых данных
   WS_NB__ZeroRBF(n);
   if (WS_R7[n].NData>79){ WS_R7[n].NData=79; }
   for(i=0; i<WS_R7[n].NData; i++){
      NV=WS_R7[n].ChNum[i] & 0x0fff;
//    CBN [NBRQ[n].ca[i]] = WS_R2[n].Data[i];
//    Val_in_DBB(NV,WS_R7[n].ChData[i]);
   }
   // Очитить структуру приема принятых данных
   WS_NB__ZeroWS_R7(n);
   return;
}
//---------------------------------------------------------------------------


//--------------------------------------------------------------------------
// Передача принятых из сети ответов в общий массив
vd WS_NB__GetReq(ui n){
   ui b=0, z=0;
   // Передать данные из буфера приема в структуру ответа
   memcpy (&WS_R2[n],&WS_RD[n],504);
   if(Debug(33)>0){
      DPrn (33,0,"\n[RECV BUF:\n");
      for(b=0;b<504;b++){ DPrn(33,0,"%c",WS_RD[n][b]); }
      DPrn (33,0,"\n]\n");
   }
   // Очистить буфер приема ответа
   WS_NB__ZeroRBF(n);
   // Номер запроса
   z= WS_R2[n].NReq;
   if(EKNBWCNT<EKNBWREQ){ EKNBWCNT++; }
   // Проверить правильность принятого буфера запроса:
   // если номер пришедшего запроса в допустимых пределах и
   // номер первого канала в ожидаемом запросе > 0

   // printf("z=%d MQR=%d NBRQ[z].cq[0]=%d",z,MQR,NBRQ[z].cq[0]);

   if(z>0 && z<MQR && NBRQ[z].cq[0]>0){
       DPrn(33,0,"ANREQ=%d  ",z);
       // для каждого канала запроса
       for(b=0;b<MRCH;b++){
           // если встретился признак конца списка запрашиваемых каналов
           if (NBRQ[z].cq[b]<1){ break; }
           if (FNBS[NBRQ[z].ca[b]]==2){ continue; }

           // Если экран поменялся- номера в DBNW[] для отображения
           // (не для архива) поменялись тоже.
           // Поэтому принятые со старого запроса значения
           // (для предыдущего экрана) запишутся  в CB[] нового экрана.
           // Пока не придет запрос посланный с нового экрана.

           // Если нет признака записи в архив- значит это канал для
           // отображения.
           // Если текущий номер запроса меньше запомненного-
           // значит это запрос с предыдущего экрана- его не воспринимаем
           if(CB[ DNBW [NBRQ[z].ca[b]] ].ar==0){
              if(EKNBWCNT<EKNBWREQ){ 
                 DPrn(33,0,"AXX%d:V%f  ",NBRQ[z].cq[b],WS_R2[n].Data[b]);
                 continue; 
              }
           }
           // иначе- записать значение запрашиваемого канала в массивы каналов
           CBN [ NBRQ[z].ca[b] ] = WS_R2[n].Data[b];
           if((CB[ DNBW [NBRQ[z].ca[b]] ].t==1)||
              (CB[ DNBW [NBRQ[z].ca[b]] ].t==3)){
               CB[ DNBW [NBRQ[z].ca[b]] ].v = WS_R2[n].Data[b];
           }
           DPrn(33,0,"ANQ%d:V%f  ",NBRQ[z].cq[b],WS_R2[n].Data[b]);
       }
       // обнулить список каналов принятого номера запроса
       for(b=0;b<MRCH;b++){ NBRQ[z].cq[b]=0; NBRQ[z].ca[b]=0; }
   } else {
      DPrn(33,0,"Неправильный номер или каналы запроса.\n");
   }
   // Очистить структуру приема ответа
   WS_NB__ZeroWS_R2(n);
   return;
}
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// Установить сетевое имя удаленной машины
ui NB_SetRName(ui NWS){
   if ((NWS>99)||(NWS<1)){ return(0); }     // Провер.номера станции
   sprintf(nbwtmpcc,"%d",NWS);              // Преобр.номера станции в строку
   WS_NBName[6]=nbwtmpcc[0];                // Запись номера станции в имя
   WS_NBName[7]=nbwtmpcc[1];    
   return(1);
}
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// Запрос значений каналов
ui WS_NB__ReqToNet(ui NWS){
   _i b=0, j=0, i=200;
   NB_SetRName(NWS);
   // Получить номер свободного NCB
   i=WS_NB__AvNCB(); CurNCFQ=0;
   // Если есть свободный NCB
   if (i>=0){
      // Очистить буфер и структуру посылки запросов
      WS_NB__ZeroSBF(i);
      WS_NB__ZeroWS_S1(i);
      // Заполнить структуру запроса:
      // Код операции запроса
      WS_S1[i].Code= 1;
      // Номер запроса
      WS_S1[i].NReq=QRC;
      DPrn(DEBNBQ,0,"SNREQ=%d  ",QRC);
      // Номера запрашиваемых каналов на удаленной станции
      for(j=0;j<MRCH;j++){
          // если номер канала меньше 1-выйти (0-признак конца записи каналов)
          if(NBRQ[QRC].cq[j]<1){ break; }
          // записать номер запрашиваемого канала в структуру запроса
          WS_S1[i].ReqData[j]=NBRQ[QRC].cq[j];
          DPrn(DEBNBQ,0,"NBQ%d  ",NBRQ[QRC].cq[j]);
      }
      // Кол-во запрашиваемых каналов
      WS_S1[i].NData=(uc)j;
      // Передать сформированную структуру запроса в буфер посылок
      memcpy (&WS_SD[i],&WS_S1[i],504);
      // Если кол-во запрашиваемых каналов больше нуля- послать запрос
      if(j>0){ WS_NB__Send(i,WS_NBName); }
      // Запись буфера запросов
      if(Debug(DEBNBQ)>0){
         DPrn(DEBNBQ,0,"\n[REQS BUF:\n");
         for(b=0;b<504;b++){ DPrn(DEBNBQ,0,"%c",WS_SD[i][b]); }
         DPrn(DEBNBQ,0,"\n]\n");
      }
      // Переустановить счетчик очереди
      QRC++; if(QRC>=MQR){ QRC=1; }
      CurNCBQ=i; CurNCFQ=1;
      return(0);
// } else {
//     sprintf(STAT_str,"ReqToNet: Нет свободного NCB."); STAT_cnt=10;
//     DPrn(DEBNBQ,0,"ReqToNet: Нет свободного NCB.\n");
   }
   return(2);
}
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
// Посылка установок
ui WS_NB__SetToNet(ui NWS){
   _i a=0,  b=0 , j=0, i=200, n=0;
   NB_SetRName(NWS);
   // Получить номер свободного NCB
   i=WS_NB__AvNCB();  CurNCFS=0;
   // Если есть свободный NCB
   if (i>=0 && i<NCBWR){
      // Очистить буфер и структуру посылки установок
      WS_NB__ZeroSBF(i);
      WS_NB__ZeroWS_S7(i);
      // Заполнить структуру посылки:
      // Код операции посылки
      WS_S7[i].Code =7;
      // Устанавливаемые каналы
      for(j=0,n=0;j<MSCH;j++){
          if(NBST[STC].cq[j] < 1){ break; }
          if(CB[ DNBW[ NBST[STC].ca[j] ] ].t==2||
             CB[ DNBW[ NBST[STC].ca[j] ] ].t==3){
             DPrn(31,0,"STN%d:V%f  ",NBST[STC].cq[j],CBN[NBST[STC].ca[j]]);
             WS_S7[i].ChNum [n]=(_s)NBST[STC].cq[j];
             WS_S7[i].ChData[n]=(_f)CBN[NBST[STC].ca[j]]; n++;
          }
      }
      DPrn(31,0,"\nJJJ%d\n",j);
      // Кол-во посылаемых каналов
      WS_S7[i].NData=(_s)n;
      // Передать сформированную структуру установки в буфер посылок
      memcpy (&WS_SD[i],&WS_S7[i],504);
      // Если кол-во устанавливаемых каналов больше нуля- послать запрос
      if(n>0){ WS_NB__Send(i,WS_NBName); }
      // Запись буфера посылок
      if(Debug(31)>0){
         DPrn(31,0,"\n[SEND BUF:\n");
         for(b=0;b<504;b++){ DPrn(31,0,"%c",WS_SD[i][b]); }
         DPrn(31,0,"\n]\n");
      }
      // Обнулить список каналов, которые передали на установку
      for(a=0;a<MSCH;a++){ NBST[STC].cq[a]=0; NBST[STC].ca[a]=0; }
      // Переустановить счетчик очереди
      STC++; if(STC>=MQR){ STC=1; }
      CurNCBS=i; CurNCFS=1;
   } else {
       sprintf(STAT_str,"SetToNet: Нет свободного NCB."); STAT_cnt=10;
       DPrn(31,0,"SetToNet: Нет свободного NCB.\n");
   }
   return(0);
}
//--------------------------------------------------------------------------
