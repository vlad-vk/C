// coding: cp866
//---------------------------------------------------------------------------
// Функции для работы со строками

#include "../include.h"
#include "../define.h"
#include "dbstr.h"

//---------------------------------------------------------------------------
// получить следующую строку из буфера
_i _mfGetStr(uc *rBuf, _i hbr){
   _i  a=0, b=0;
   // для каждого символа буфера, пока не конец строки
   for(a=GStrPos; a<hbr; a++){
       // определить конец строки
       if (rBuf[a]==10){ 
           GStrPos=a+1; GStr[b]=0; return(1); 
       }
       // записать строку
       if (rBuf[a]>=27){ GStr[b]=rBuf[a]; if(b<SLEN-1){ b++; }; GStr[b]=0; }
   }  
   GStrPos=0;
   return(0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// заполнить массив полей текущей строки (записи)
// r    - номер формируемой записи
// GStr - разбираемая строка
_i PutFields(_i r, uc *GStr, ...){
   va_list argptr;
   _i a=0, b=0, c=0, d=0, e=0, f=0;
   _i l=strlen(GStr);
   // если строка пустая - выйти
   if(l<1){ return(0); }
   // передача парамметров в массив разделителей
   va_start(argptr,GStr);
   for(a=0;a<SLEN;a++){
       GSRFld[a]=(uc)va_arg(argptr,int); if(GSRFld[a]==0){ break; }
   }
   va_end  (argptr);
   // обнулить первое поле
   GFld[r][b][c]=0;
   // для каждого символа строки
   for(a=0; a<=l; a++, e=0){
       // если встретился символ разделитель полей
       for(d=0; d<LSRR && GSRFld[d]>0; d++){
           if((GStr[a]==GSRFld[d])||(GStr[a]==0)){
               // запомнить первый встретившийся разделитель полей
               if(f==0){ f=GSRFld[d]; }
               // сбросить флаги
               e=1; if(b<MFLD-1){ b++; }; c=0; GFld[r][b][0]=0; 
           }
       }
       // заполнить текущее поле
       if (e==0){
           GFld[r][b][c]=GStr[a]; if(c<SLEN-1){ c++; }; GFld[r][b][c]=0;
       }
   }
   // в оставшихся полях обнулить нулевой символ
   if (e==0){ GFld[r][b][0]=0; }
   for(b++,HowFLD=b; b<MFLD; b++){ GFld[r][b][0]=0; }
   // вернуть первый встретившийся разделитель полей
   return(f);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Вернуть строку из запрашиваемого поля
uc * GetField(_i nREC, _i nFLD){
     if (GFld[nREC][nFLD][0]==0){ return(""); }
     else                       { return(GFld[nREC][nFLD]); }
}
//---------------------------------------------------------------------------
// Получить из переданной строки заданное по номеру поле
uc   FldStr[1024];
uc * GetFieldFromStr(uc *String, uc Razdelit, _i FNumber){
     _i  a=0, b=0, f=0, L=strlen(String), r=1, z=0;
     for(a=0; a<L; a++){
         // если текущий символ разделитель и было считано поле
         if((String[a]==Razdelit&&f==1)||(String[a]==0)){
            b=0; f=0; if(r==FNumber) break; r++; continue;
         }
         if(String[a]==Razdelit) continue;
         // если текущий символ не разделитель, предыдущий был разделитель
         if(String[a]!=Razdelit&&f==0) f=1;
         // если номер поля равен заданному- считать его в переменную
         if(r==FNumber){
            FldStr[b]=String[a]; if(b<1023) b++; FldStr[b]=0; z=1;
         }
     }
     if(z==1){ return(FldStr); }
     else    { return("");     }
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Вернуть статус указанного поля (0-нет поля, 1-есть)
_i isField(_i nREC, _i nFLD){
   if (GFld[nREC][nFLD][0]==0){ return(0); }
   else                       { return(1); }
}
//---------------------------------------------------------------------------
// Вернуть байт в поле
_i isFieldb(_i nREC, _i nFLD, _i bt){ return(GFld[nREC][nFLD][bt]); }
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Вернуть количество вхождений заданного символа в указанном поле
_i GetCHR_in_FLD(_i nREC, _i nFLD, uc sCHR){
   _i  a=0, r=0;
   for(a=0; a<strlen(GFld[nREC][nFLD]); a++){
       if(GFld[nREC][nFLD][a]==sCHR){ r++; }
   }; return(r);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Очистить текущую строку
_i ClearGStr(vd){
   _i  a=0;
   for(a=0; a<SLEN; a++){ GStr[a]=0; }
   return(0);
}
//---------------------------------------------------------------------------

