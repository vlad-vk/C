// coding: cp866
//---------------------------------------------------------------------------
// md=1 - открытие файла на чтение
// md=0 - закрытие файла
_i Init_CFG(_i md){
   _i  r=0;
   //------------------------------------------------------------------------
   // закрытие файла
   if (md==0){
       if (FDCfg>0){ close(FDCfg); }
   }
   //------------------------------------------------------------------------
   // открытие файла
   if (md==1){
      if (FNCfg!=NULL){
          FDCfg=open(FNCfg,O_RDONLY,S_IREAD);
      }  else  { FDCfg=0; }
      if (FDCfg<0){ 
          FHCfg=0; r=-1; 
          if(FNCfg[0]==0||FNCfg[0]==32){ r=0; }
      }
   }
   //------------------------------------------------------------------------
   // чтение файла
   if (md==2){
      if (FDCfg>0){
          FHCfg=read(FDCfg,FBuf,SBuf);
      }
      if(FHCfg<1){ FHCfg=0; r=1; }
   }
   //------------------------------------------------------------------------
   return(r);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Загрузка значений из буфера конфигурации
// sec - идентификатор секции
// t   - тип аргумента 'i','l','f','c'
// cvt - указатель на структуру указателей переменных
//
_i Load_CFG(_i sec,  _i t,  CVT * cvt){
   _i  a=0,b=0,d=0,h=0,z=0;
   uc c[9]= {0,0,0,0,0,0,0,0,0};
   uc u[9]= {0,0,0,0,0,0,0,0,0};
   uc f[7]= {'%','-','9','.','0','f', 0 };
   // если конец разбираемой строки
   if (FBuf[lca]==10){
      // если обрабатывалось числовое значение
      if (t!='c'){
          rvl[2]=atof(lcc);
          if (rvl[0]==0){ rvl[1]=0; };
          if (rvl[0]==2){ rvl[2]= -rvl[2]; }
          if (rvl[0]==3){ rvl[2]=  rvl[1]* rvl[2]; rvl[1]=0; }
      }
      if (t=='c') { cvt->c[lcz]=0;     }
      if (t=='i') { cvt->i=(_i)(rvl[1]+rvl[2]); }
      if (t=='l') { cvt->l=(_l)(rvl[1]+rvl[2]); }
      if (t=='f') { cvt->f=(_f)(rvl[1]+rvl[2]); }
      // установка значений элементов 'y ...'
      if (LMVLDF>0&&LMVLCN>0){ 
          sprintf(LMVL[LMVLCN],"%9f",(_f)(rvl[1]+rvl[2]));
          YCM[LMVLCN]=atof(LMVL[LMVLCN]);
      }
      // обнулить флаги и переменные
      lcz=0; lcstr=0; rvl[0]=0; rvl[1]=0; rvl[2]=0; LMVLCN=LMVLDF=0;
      return(10);
   }
   // если установлен флаг пропуска символов
   if (lcl==5 || LNstr==1){ return(1); }
   // если встретился символ комментария - установить флаг пропуска символов
   if (FBuf[lca]==59){ lcl=5; return(1); }
   // если встретился символ продолжения строки
   if (FBuf[lca]==92){ LNstr=1; return(1); }
   // не учитывать вначале строки незначащие пробелы
   if((lcl==0)&&(FBuf[lca]==32)){ return(1); }
   // если секция определена - установить необходимые флаги
   if (lcl==0){
       if ((strchr(lcsok,FBuf[lca]))==NULL){ return(1); }
       lcl=1; lcsec=FBuf[lca]; return(2);
   }
   if (lcsec!=sec){ return(1); }
   //------------------------------------------------------------------------
   // если секция определена
   if (lcsec>0){
       //--------------------------------------------------------------------
       // если считываем строковую переменную
       if (t=='c'){
          // если это первые кавычки, открывающие строку-
          // установить флаг начала обработки строки
          if((FBuf[lca]==34)&&(lcstr==0)){ lcstr=1; return(1); }
          // если это вторые кавычки или пробел, закрывающие строку-
          // обнулить счетчики и закрыть строку нулем
          if((FBuf[lca]==34||FBuf[lca]==0)&&(lcstr==1)){
              cvt->c[lcz]=0; lcz=0; lcstr=0; 
              return(5);
          }
          // разбор строки
          if (lcstr==1){
              // каждые 4 символа забрать в буфер преобразования номера макроса
              c[0]=FBuf[lca+1]; c[1]=FBuf[lca+2]; c[2]=FBuf[lca+3];
              c[3]=FBuf[lca+4]; c[4]=FBuf[lca+5]; c[5]=FBuf[lca+6];
              //------------------------------------
              if(FBuf[lca]=='@'&&
                (c[0]>=48&&c[0]<58)&&(c[1]>=48&&c[1]<58)&&(c[2]<48||c[2]>=58)){
                 strcpy(u,c);  u[2]=0;
                 // получить номер переменной из строки
                 b=atoi(u); if(b>=MYCM) b=MYCM-1;
                 // получить значение из команды "y"
                 sprintf(LMVL[b],f,YCM[b]);
                 // подавить пробелы в строке значения
                 for(z=0;z<strlen(LMVL[b]);z++){
                     if(LMVL[b][z]==32){ LMVL[b][z]=0; break; }
                 }
                 if(LMVL[b][0]>=48&&LMVL[b][0]<58){
                    c[0]=LMVL[b][0];
                    if(LMVL[b][1]>=48&&LMVL[b][1]<58){
                       c[1]=LMVL[b][1];
                    }
                 }
                 // переопределить макрос "@", как макрос "$"
                 FBuf[lca]='$';
              }
              //------------------------------------
              // если это определение номера макроса (комманды "Y")
              if(FBuf[lca]=='$'&&(c[0]>=48&&c[0]<58)){
                 c[2]=0;
                 // получить номер макроса из строки
                 b=atoi(c); if(b>=MDIR){ b=MDIR-1; }
                 cvt->c[lcz]=0; d=lcz;
                 // добавить строку макроса к уже считанной строке
                 if(strlen(cvt->c)+strlen(LDIR[b])<SLEN-1){
                    strcat(cvt->c,LDIR[b]); lcz=strlen(cvt->c);
                    b=lca;
                    // увеличить текущее положение в обрабатываемом буфере
                    if(c[1]>=48&&c[1]<58){ lca=lca+2; } 
                    else                 { lca=lca+1; }
                 }  else { b=0; d=0; }
                 cvt->c[lcz]=0;
                 // обработка записи типа: Y$30
                 if(b>0){
                    if(FBuf[b-1]=='Y'){
                       // если значения после Y не цифровые- выйти
                       if((cvt->c[1]<48||cvt->c[1]>57)||
                          (cvt->c[2]<48||cvt->c[2]>57)){
                         d=0; return(1);
                       }
                       // привести строку к виду Y00
                       c[0]=cvt->c[1]; c[1]=cvt->c[2]; c[2]=0;
                       // и передать на дальнейшую обработку
                       lcz=d-1; cvt->c[lcz]=0; d=1; lca=b-1;
                    } else { d=0; }
                 }; if(d==0) return(1);
              }
              //------------------------------------
              // Если это номер макроса 'Y'
              // подставить готовое(вычесленное) значение этого макроса в строку
              if(FBuf[lca]=='Y'&&(c[0]>=48&&c[0]<58&&c[1]>=48&&c[1]<58)){
                 c[2]=0;
                 // получить номер макроса Y
                 b=atoi(c); if(b>=MDIR){ b=MDIR-1; }
                 cvt->c[lcz]=0;
                 // обработать строку макроса
                 strcpy(YCNV.str,LDIR[b]);
                 MESOut((MOUT*)&YCNV,4,0);
                 strcpy(LDIR[b],YCNV.str);
                 // вернуть обработанную строку в текущую строку
                 if(strlen(cvt->c)+strlen(LDIR[b])<SLEN-1){
                    strcat(cvt->c,LDIR[b]); lcz=strlen(cvt->c);
                 } 
                 lca=lca+2+d; cvt->c[lcz]=0; d=0;
                 return(1);
              }
              //------------------------------------
              // Если это определение номера переменной (комманды "y").
              // Если переменная считывается здесь (при загрузке) она потом
              // не изменяется. Для динамического изменения значения надо
              // указывать в строке макрос '@' с таким же синтаксисом.
              // Примеры форматов записи в файле описания: 
              // Y "Страница: y0070" ;   Y "Температура ($10): y0150.2"
              if(FBuf[lca]=='y'&&(c[0]>=48&&c[0]<58&&c[3]>=48&&c[3]<58)){
                 // получить номер переменной из строки
                 b=atoi(c); if(b>=MYCM){ b=MYCM-1; }
                 cvt->c[lcz]=0;  
                 // количество обработанных символов входной строки
                 h=4; 
                 // шестая цифра в номере канала определяет количество
                 // цифр после запятой (по умолчанию 0)
                 if(c[4]=='.' && c[5]>=48 && c[5]<58){ f[4]=c[5]; h=6; }
                 sprintf(LMVL[b],f,YCM[b]);
                 // подавить пробелы в строке значения
                 for(z=0;z<strlen(LMVL[b]);z++){
                     if(LMVL[b][z]==32){ LMVL[b][z]=0; break; }
                 }
                 // добавить строку значения к уже считанной строке
                 if( strlen(cvt->c)+strlen(LMVL[b])<SLEN-1){
                     strcat(cvt->c,LMVL[b]); lcz=strlen(cvt->c);
                 }
                 lca=lca+h; cvt->c[lcz]=0;
                 return(1);
              }
              //------------------------------------
              // разбор строки дальше
              cvt->c[lcz]=FBuf[lca]; if(lcz<SLEN-1){ lcz++; }
          }
       }
       //--------------------------------------------------------------------
       // если считываем цифровую переменную
       else {
          // если определено установка нового значения для указанного элемента
          if (FBuf[lca]=='='){ LMVLDF=1; return(1); }
          // если это определение номера макроса (комманда 'y')
          if (FBuf[lca]=='$'&&(FBuf[lca+1]>=48&&FBuf[lca+1]<58)){ 
              c[0]=FBuf[lca+1];  c[1]=0;  c[2]=0;  c[3]=0;  c[4]=0;  h=1;
              if(FBuf[lca+2]>=48&&FBuf[lca+2]<58){
                 c[1]=FBuf[lca+2];        c[2]=0;  c[3]=0;  c[4]=0;  h=2;
                 if(FBuf[lca+3]>=48&&FBuf[lca+3]<58){
                    c[2]=FBuf[lca+3];     c[3]=0;  c[4]=0;   h=3;
                    if(FBuf[lca+4]>=48&&FBuf[lca+4]<58){
                       c[3]=FBuf[lca+4];  c[4]=0;  h=4;
                    }
                 }
              }
              // получить номер ячейки массива 'y' из строки
              b=atoi(c); if(b>=MYCM){ b=MYCM-1; }; 
              sprintf(LMVL[b],"%9f",YCM[b]); strcpy(lcc,LMVL[b]);
              // запомнить номер элемента масива LMVL[] и YCM[]
              if(LMVLCN==0){ LMVLCN=b; }
              // увеличить текущее положение в обрабатываемом буфере
              lca=lca+h;
              return(1);
          }
          // если это дополнительное действие
          if (FBuf[lca]=='+' ||FBuf[lca]=='-'||FBuf[lca]=='*'){
             // если это не первое действие - перенести число
          if(rvl[0]!=0){ z=rvl[0]; rvl[2]=rvl[1]; }
             if(FBuf[lca]=='+'){ rvl[0]=1; }    // если текущее действие '+'
             if(FBuf[lca]=='-'){ rvl[0]=2; }    // если текущее действие '-'
             if(FBuf[lca]=='*'){ rvl[0]=3; }    // если текущее действие '*'
             // преобразовать считанную строку в число
             rvl[1]=atof(lcc); lcz=0; 
         // выполнить предыдущее действие...
             if(z==1){ rvl[1]=rvl[2]+rvl[1]; }  // если предыдущее действие '+'
             if(z==2){ rvl[1]=rvl[2]-rvl[1]; }  // если предыдущее действие '-'
             if(z==3){ rvl[1]=rvl[2]*rvl[1]; }  // если предыдущее действие '*'
             return(1);
          }
          // если код текущего символа больше, чем код цифр - выйти
          if (FBuf[lca]> 58){ return(1); }
          // если код текущего символа больше, чем код пробела - записать
          if (FBuf[lca]> 32){
             lcc[lcz]=FBuf[lca]; if(lcz<CVTLEN-1){ lcz++; lcc[lcz]=0; }
             return(1);
          }
          // если текущий символ пробел или конец строки - обработать 
          // записанный буфер строки
          if ((FBuf[lca]==32)&&((strlen(lcc))>0)){
             // преобразовать записанный буфер строки в число
             rvl[2]=atof(lcc);
             if (rvl[0]==0){ rvl[1]=0; };
             if (rvl[0]==2){ rvl[2]= -rvl[2]; }
             if (rvl[0]==3){ rvl[2]=  rvl[1]* rvl[2]; rvl[1]=0; }
             if (t=='i') { cvt->i=(_i)(rvl[1]+rvl[2]); }
             if (t=='l') { cvt->l=(_l)(rvl[1]+rvl[2]); }
             if (t=='f') { cvt->f=(_f)(rvl[1]+rvl[2]); }
             // установка значений элементов 'y ...'
             if (LMVLDF>0&&LMVLCN>0){  
                 sprintf(LMVL[LMVLCN],"%9f",(_f)(rvl[1]+rvl[2]));
                 YCM[LMVLCN]=atof(LMVL[LMVLCN]);
             }
             // обнулить буфер строки, флаги и переменные
             for(a=0;a<CVTLEN;a++){ lcc[a]=0; }
             lcz=0; lcstr=0; rvl[0]=0; rvl[1]=0; rvl[2]=0; LMVLCN=LMVLDF=0;
             return(5);
          }
       }
       //--------------------------------------------------------------------
   }
   return(1);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// обнуление флагов и счетчиков считывания
_i ClsFlg(vd){
   int a=0;
   for(a=0;a<CVTLEN;a++){ lcc[a]=0; }  // буфер текущего преобразования числа
   lcs  =1;                            // номер переменной в строке
   lcz  =0;                            // счетчик буфера lcc[]
   lcl  =0;                            // флаг управления (коментария)
   lcsec=0;                            // флаг секции
   lcstr=0;                            // флаг начала записи строки
   rvl[0]=0; rvl[1]=0; rvl[2]=0;       // обработка значений в коммандах
   LMVLCN=LMVLDF=0;                    // установка значений элементов 'y ...'
   return(0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// если в файле описания переменная записана строкой -
// заполнить ее номерные поля в структуре
vd ValStr(_i n, _i m){
   _i  a =0, b=0;
   if (m=='v'){
       LVAL[n].na=0;
       for(a=0; a<MCH; a++){
           if((strncmp(SVAL, CB[a].nm, strlen(SVAL)))==0){ LVAL[n].nv=a; break; }
       }
       if (a>=MCH){ LVAL[n].nv=0; }
   }
   if (m=='g'){
       LGST[n].na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LGST[n].nv=a; break; }
       }
       if (a>=MCH){ LGST[n].nv=0; }
   }
   if (m=='C'){
       LCST[n].na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LCST[n].nv=a; break; }
       }
       if (a>=MCH){ LCST[n].nv=0; }
   }
   if (m=='a'){
       LANI[n].na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LANI[n].nv=a; break; }
       }
       if (a>=MCH){ LANI[n].nv=0; }
   }
   if (m=='p'){
       LPLZ[n].na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LPLZ[n].nv=a; break; }
       }
       if (a>=MCH){ LPLZ[n].nv=0; }
   }
   if (m=='G'){
       LGET[n].na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LGET[n].nv=a; break; }
       }
       if (a>=MCH){ LGET[n].nv=0; }
   }
   if (m=='c'){
       LXCV[n].na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LXCV[n].nv=a; break; }
       }
       if (a>=MCH){ LXCV[n].nv=0; }
   }
   if (m=='t'){
       for(a=0; a<MTRG; a++){
           for(b=0; b<MCH; b++){
               if((strcmp(LTRD[n].m[a], CB[b].nm))==0){ LTRD[n].n[a]=b; break; }
           }
       }
   }
   if (m=='Q'){
       LSLM[n].na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LSLM[n].nv=a; break; }
       }
       if (a>=MCH){ LSLM[n].nv=0; }
   }
   if (m=='F'){
       LFST.na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LFST.nv=a; break; }
       }
       if (a>=MCH){ LFST.nv=0; }
   }
   if (m=='?'){
       LOPQ[n].na=0;
       for(a=0; a<MCH; a++){
           if((strcmp(SVAL, CB[a].nm))==0){ LOPQ[n].nv=a; break; }
       }
       if (a>=MCH){ LOPQ[n].nv=0; }
   }
   return;
}
//---------------------------------------------------------------------------
