// coding: cp866
//---------------------------------------------------------------------------
// вывод сообщений из внешних функций
vd StatMsgExt(vd){
   if (STAT_cnt>0&&ErrCNT==0){
       strcpy(STAT[1].str,STAT_str); STAT[1].cnt=STAT_cnt; STAT_cnt=0;
   }
   return;
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// первая пользовательская функция в цикле
_i First_in_Cycle(vd){
   return(0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Обмен данными по COM порту под Windows (фоновый процесс)
DWORD WINAPI ExchangeCOM(void){
      printf("Start: ExchangeCOM.\n");
      for(;;){
          if(SSTAT>0){
             inp_COM(CurSP);
             COMBusy[CurSP]=0;
             DRV_Ser(CurSP);
             out_COM(CurSP);
          }
          if(TCP_ExitSRV>0) break;
          win_delay('u',SPHREQ*REREQS);
          Sleep(1);
      }
      return(0);
}
//---------------------------------------------------------------------------
// Обмен данными(в режиме прием-ответ) через NetBIOS под Windows
DWORD WINAPI WS_NB__NetChange(void){
   _i  i=0, x=0, z=0;
   printf("Start: ExchangeNetBIOS.\n");
   for(;;){
   if(x>900) x=0;
   // для каждого NCB
   for(i=0;i<NCBWR;i++){
      // printf("-");
      if(i==CurNCBQ || i==CurNCBS){ continue; }
      // printf("+");
      //---------------------------------------------
      // если принят код запроса
      if (WS_RD[i][0]==1 &&
          WS_NB__GetRetCCode  (i)==0x00&&
          WS_NB__GetFinalCCode(i)==0x00){
          if(Debug(30)>0){ printf("Q%d ",x); x++; }
          z=WS_NB__AvNCB();
          if(z>=0){
             WS_NB__Answer(i,z);
             WS_NB__Send(i,WS_NB__GetCallName(i));
          }
          WS_NB__ZeroNCB(i);
      }
      //---------------------------------------------
      // ответ от удаленной станции
      if (WS_RD[i][0]==2 &&
          WS_NB__GetRetCCode  (i)==0x00&&
          WS_NB__GetFinalCCode(i)==0x00){
          if(Debug(30)>0){ printf("A%d ",x); x++; }
          // Передача принятых из сети ответов в массив обмена
          WS_NB__GetReq(i);
          // Изменение флагов и счетчиков обмена по сети NETBIOS
          STNBW=0;
          STNBO++; if (STNBO>40){ STNBO=40; }
          NBREQASK++; if(NBREQASK>100000){ NBREQASK=0; }
          WS_NB__ZeroNCB(i);
      }
      //---------------------------------------------
      // если принят код установки - меняем значения каналов в DBB[]
      if (WS_RD[i][0]==7 &&
          WS_NB__GetRetCCode  (i)==0x00&&
          WS_NB__GetFinalCCode(i)==0x00){
          if(Debug(30)>0){ printf("S%d ",x); x++; }
          WS_NB__GetFromNet(i);
          WS_NB__ZeroNCB(i);
      }
      //---------------------------------------------
      // включение готовности NCB для приема данных из сети
      if (WS_NB__GetRetCCode  (i)==0x00&&
          WS_NB__GetFinalCCode(i)==0x00){
          if(Debug(30)>0){ printf("R%d ",x); x++; }
          WS_NB__Receive(i);
          STNBW=0;
      }
      //---------------------------------------------
      if(TCP_ExitSRV>0) break;
      //printf("!");
   };
   if(TCP_ExitSRV>0) break;
   Sleep(1);
   }
   Quit_NB();
   return(0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// функции на каждый цикл
_i EveryCyc(vd){
   if((MTimer(2,'m',NBFRQ))==2){
       MTimer(2,'m',0);
       DRV_Loc();
       if (NSTAT>0){ DRV_NBw();  }
       if (TSTAT>0){ DRV_TCP(1); }          // 0=init, 1=exchange, 2=close
   }
   return(0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// функции на каждый тик
_i EveryTic(vd){
   _i a=0;

   // обработка нажатий клавиш
   MLastKey(0);
   // запросить нажатие клавиш мышки
   MMousKey();
   // получить текущее время
   GetTime(1);

   //------------------------------------------------------------------------
   // Если код был сгенерирован из определения области
   if (SelCode>0){ SCode=SelCode; LCode=SelCode; LASTKEY=SelCode; SelCode=0; }
   //------------------------------------------------------------------------
   // Взять сканкод для обработки запросов оператору
   if (SCode  >0){ COPK=SCode; }
   //------------------------------------------------------------------------

   //------------------------------------------------------------------------
   // вызов обмена с драйверами
   EveryCyc();
   //------------------------------------------------------------------------
   // вызов внешних функций из коммандного файла
   RunCMD();

   //------------------------------------------------------------------------
   // запросы для оператра
   if (SCode>0){ RunOPQ(0); }
   //------------------------------------------------------------------------
   if (DPcnt[0]>5  || ReDraw>0){
       DPcnt[0]=0;    ReDraw=0;
       // рисуем тренды
       TRDScr();
       // рисуем шкалы
       for(a=0;a<HSHK;a++){ MDraw_Shk(a); }
       // рисуем гистограммы
       GisScr();
       // выводим переменные и гистограмы на экран
       ValScr();
       // вывести одиночные спрайты
       for(a=0; a<HSPR; a++){ MLoad_Spr(a,1,0,0); }
       // вывести строки выбора
       Choice (1);
   }
   // 
   if (DPcnt[4]>20){
       DPcnt[4]=0;
       // мигание курсора при вводе значений
       LGET_rn=(LGET_rn==0)?1:0;
   }
   //------------------------------------------------------------------------

   //------------------------------------------------------------------------
   if (DPcnt[1]>2||RKDraw>0){
       DPcnt[1]=0;
       // отображение файлов
       for(a=0;a<HFVW;a++){
           if(FVA!=a){ ViewFile(a,1); }
       }
       ViewFile(FVA,1);
       // выводим сообщение из буфера, если оно там есть
       rMessageOut();
       // поиск в архиве по времени
       if(FTC>0){ RACTSeek(); }
       // проверка кодов программы контроллера
       CheckCSPC();
       // вывести сообщение статуса
       MESOut((MOUT*)&STAT[1],0,0);
       // вывести сообщение контроллера
       MESOut((MOUT*)&MESS[1],1,0);
       // вывести сообщение из файла для экрана
       FChoice(1);
   }
   //------------------------------------------------------------------------

   //-------------------------------------------------------------------------
   // записать текущую запись архива в файл
   ArcWrite();
   UpdWrite();
   // ввод данных и строк
   if (GS.FL==0){
       a=GetVal(LGET_st,1);
   }   else   {
   // ввод строк (даты,времени)
       a=GetStr(1);
       // установить дату  просм архива
       if((a==KEY_ENTER || a==KEY_ENTER_PAD) && GS.fe==1){ SetDateArc(); }
       // установить время просм архива
       if((a==KEY_ENTER || a==KEY_ENTER_PAD) && GS.fe==2){ SetTimeArc(); }
       // установить дату  просм отчета
       if((a==KEY_ENTER || a==KEY_ENTER_PAD) && GS.fe==3){ SetDateRep(); }
       // поиск в файле
       if((a==KEY_ENTER || a==KEY_ENTER_PAD) && GS.fe==4){ SetFindStr(); }
       //  GS.fe==5 - прямой поиск строки
       //  GS.fe==6 - обратный поиск строки
       // окончание ввода рабочих строк
       if((a==KEY_ENTER || a==KEY_ENTER_PAD || a==KEY_ESC) && GS.fe==7){
           GetWStr(0,1);
       }
   }
   // остановка анимации...
   if (a==KEY_ESC || a==KEY_ENTER || a==KEY_ENTER_PAD){ Animation(4); }
   //-------------------------------------------------------------------------
   // перерисовка графических примитивов
   if (HBOX>0){
       for(a=0;a<HBOX;a++){
           if(LBOX[a].vw==5){
              MDraw_Box(a,0,LBOX[a].n,LBOX[a].X,LBOX[a].Y,
                            LBOX[a].W,LBOX[a].H,LBOX[a].cs);
       };  };
   }
   RKDraw=0;
   //-------------------------------------------------------------------------
   // перерисовка кнопок областей
   if (FLSEL>0){
       if (HSEL>0){
           for(a=0;a<HSEL;a++){ DrawSPRKNP(a); };
           MMousSEL(FLSEL);
           FLSEL=0;
       }
   }
   //-------------------------------------------------------------------------
   // повторный вывод на экран кнопок меню
   if (PutButton()>0 || fSTR>0){ MenuStrOUT(); }
   // вывести ползунки
   Polzun(1,0);
   //-------------------------------------------------------------------------
   // вывести картинки анимации
   Animation(1);
   // вывести спрайты, которые нужны поверх всего (vw=3)
   for(a=0; a<HSPR; a++){ MLoad_Spr(a,3,0,0); }
   // информации об авторе 1-поочередно, 2-режим "бегущ строка"
   MesAUTH(2,20);

   //-------------------------------------------------------------------------
   // перерисовка экрана
   if (BFirst>0){ 
       CodusScrRefresh();
   }
   //-------------------------------------------------------------------------
   // восстановить экран под спрайтом анимации
   Animation(2);

   //-------------------------------------------------------------------------
   if (DPcnt[6]>2){
        // установка флага генерации отчета (FREP=CBL[28])
        if (FREP> 0){ Report(1); FREP=0; }
        // печать отчета
        if (FLGP> 0){ PrintFile(2); }
        DPcnt[6]= 0;
   }
   //-------------------------------------------------------------------------
   // увеличить счетчики циклов
   DPcnt[0]++;
   DPcnt[1]++;
   DPcnt[4]++;
   DPcnt[6]++;

   return(0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// функции на каждую секунду
_i EverySec(vd){
   // проверка сообщений из внешних функций
   StatMsgExt();
   // запрос для оператора
   RunOPQ(1);
   // подсчет счетчиков обмена по COM порту за 10 сек
   if (DPcnt[3]>=10){
       DPcnt[3] =0;
       if(ANSERCNT>RQSERCNT) ANSERCNT=RQSERCNT;
       TOSERCNT =RQSERCNT- ANSERCNT;
       CBL [24] =RQSERCNT; RQSERCNT=0;      // колич запросов
       CBL [26] =ANSERCNT; ANSERCNT=0;      // колич ответов
       CBL [25] =TOSERCNT; TOSERCNT=0;      // колич таймаутов
   };  DPcnt[3]++;
   //
   if (DPcnt[7]>=21){
       DPcnt[7] =0;
   };  DPcnt[7]++;
   // раз в час проверка свободного места на диске
   if (HourPrev!=tmm->tm_hour){
       HourPrev =tmm->tm_hour;
       if (gDiskFree(1)){ gDiskFree(0); }
   }
   // пустые циклы CODUS за тик в редактор
   El_Cyc=CBL[1];
   if(WaitPressKey<(60*60*24)){ WaitPressKey++; }
   return (0);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// последняя функция в цикле
_i Last__in_Cycle(vd){
   return(0);
}
//---------------------------------------------------------------------------
